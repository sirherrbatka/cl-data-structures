(cl:in-package #:cl-data-structures.threads)


(defun traverse (object function &key (batch-size 64) (queue-size 128))
  (bind ((tasks (make-hash-table :test 'eq))
         (lock (bt2:make-lock))
         (cv (bt2:make-condition-variable))
         (buffer (make-array batch-size :adjustable t :fill-pointer 0)))
    (cl-ds:traverse object (lambda (x)
                             (vector-push-extend x buffer)
                             (when (= (fill-pointer buffer) batch-size)
                               (bt2:with-lock-held (lock)
                                 (setf (gethash buffer tasks)
                                       (cl-ds.utils:with-rebind (buffer)
                                         (lparallel:future
                                           (cl-ds.utils:rebind
                                            (map nil function buffer)
                                            (bt2:with-lock-held (lock)
                                              (remhash buffer tasks)
                                              (bt2:condition-notify cv)))))))
                               (setf buffer (make-array batch-size :adjustable t :fill-pointer 0))
                               (bt2:with-lock-held (lock)
                                 (iterate
                                   (while (>= (hash-table-count tasks) queue-size))
                                   (bt2:condition-wait cv lock))))))
    (let ((final (lparallel:future (map nil function buffer))))
      (maphash-values (lambda (x) (lparallel:force x))
                      tasks)
      (lparallel:force final))
    object))

(defun across (object function &key (batch-size 64) (queue-size 128))
  (bind ((tasks (make-hash-table :test 'eq))
         (lock (bt2:make-lock))
         (cv (bt2:make-condition-variable))
         (buffer (make-array batch-size :adjustable t :fill-pointer 0)))
    (cl-ds:across object (lambda (x)
                           (vector-push-extend x buffer)
                           (when (= (fill-pointer buffer) batch-size)
                             (bt2:with-lock-held (lock)
                               (setf (gethash buffer tasks)
                                     (cl-ds.utils:with-rebind (buffer)
                                       (lparallel:future
                                         (cl-ds.utils:rebind
                                          (map nil function buffer)
                                          (bt2:with-lock-held (lock)
                                            (remhash buffer tasks)
                                            (bt2:condition-notify cv)))))))
                             (setf buffer (make-array batch-size :adjustable t :fill-pointer 0))
                             (bt2:with-lock-held (lock)
                               (iterate
                                 (while (>= (hash-table-count tasks) queue-size))
                                 (bt2:condition-wait cv lock))))))
    (let ((final (lparallel:future (map nil function buffer))))
      (maphash-values (lambda (x) (lparallel:force x))
                      tasks)
      (lparallel:force final))
    object))
